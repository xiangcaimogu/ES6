https://juejin.cn/post/6984188410659340324#heading-12


接着我们找到 Performance 这一面板，之前叫 Timeline ，它是 Chrome Devtool 用来监控性能指标的一个利器，
可以记录并分析在网站的生命周期内所发生的各类事件，我们就可以通过它监控我们程序中的各种性能情况并分析，其中就包括内存。

接下来开始操作，在开始之前一定要确认勾选了 Memory 选项也就是上图标记 5 ，这样我们才可以看到内存相关的分析。
点击开始录制（标记 1）进入录制状态，随后先清理一下GC（触发垃圾回收），也就是点击小垃圾桶（标记 6）。
接着疯狂点击页面中 click 按钮 100 次，这时页面上的数值应该是 200，我们再点击一下小垃圾桶，手动触发一次 GC。
再次疯狂点击页面中 click 按钮 100 次，这时页面上的数值应该是 400，然后停止录制。
如图1
上面圈红的两块，也就是 Heap 对应的部分表示内存在周期性的回落，简单说就是我们的内存情况。
我们可以很明显的看到，内存数据呈现出一个不断上涨的趋势，可能有人会说这段时间内是不是还没执行 GC 呢？别急，还记得我们在 200 的时候点击了一下小垃圾桶吗，也就是我们中间手动触发垃圾回收一次
可以看到，即使我们中间手动做了一次垃圾回收操作，但清理后的内存并没有减少很多，由此我们推断，此程序的点击操作可能存在内存泄漏

## 分析定位
Chrome Devtool 还为我们提供了 Memory 面板，它可以为我们提供更多详细信息，比如记录 JS CPU 执行时间细节、显示 JS 对象和相关的DOM节点的内存消耗、记录内存的分配细节等。
其中的 Heap Profiling 可以记录当前的堆内存 heap 的快照，并生成对象的描述文件，该描述文件给出了当下 JS 运行所用的所有对象，以及这些对象所占用的内存大小、引用的层级关系等等，用它就可以定位出引起问题的具体原因以及位置。
注意，可不是 Performance 面板下那个 Memory ，而是与 Performance 面板同级的 Memory 面板，

现在页面值为 400，当然也可以刷新一下页面从 0 开始，这里我们选择继续操作
首先点击一下小垃圾桶（标记 3），触发一下 GC，把没用的东西从内存中干掉
点击开始生成快照（标记 1），生成第一次快照并选中，
如图2

左侧列表中的 Snapshot 1 代表了我们生成的快照1，也就是刚刚那一刻的内存状态
选中 Snapshot 1 后就是右侧视图表格了，表格左上方有一个下拉框，它有四个值

Summary：按照构造函数进行分组，捕获对象和其使用内存的情况，可理解为一个内存摘要，用于跟踪定位DOM节点的内存泄漏
Comparison：对比某个操作前后的内存快照区别，分析操作前后内存释放情况等，便于确认内存是否存在泄漏及造成原因
Containment：探测堆的具体内容，提供一个视图来查看对象结构，有助分析对象引用情况，可分析闭包及更深层次的对象分析
Statistics：统计视图

该下拉默认会为我们选择 Summary ，所以下方表格展示的就是快照1中数据的内存摘要，简单理解就是快照1生成的那一刻，内存中都存了什么，包括占用内存的信息等等。
来简单了解下 Summary 选项数据表格的列都表示什么

Constructor：显示所有的构造函数，点击每一个构造函数可以查看由该构造函数创建的所有对象
Distance：显示通过最短的节点路径到根节点的距离，引用层级
Shallow Size：显示对象所占内存，不包含内部引用的其他对象所占的内存
Retained Size：显示对象所占的总内存，包含内部引用的其他对象所占的内存

OK，暂时知道这么多就可以了，我们继续操作，先点击小垃圾桶手动执行一次GC，然后点击 1 下页面的 click 按钮，最后再次点击生成快照按钮，生成我们的第二次快照。
为了准确无误，我们多来几次操作，如下：
先点击小垃圾桶手动执行一次 GC，然后点击 2 下页面的 click 按钮，最后再次点击生成快照按钮，生成我们的第三次快照
先点击小垃圾桶手动执行一次 GC，然后点击 3 下页面的 click 按钮，最后再次点击生成快照按钮，生成我们的第四次快照
随后，我们选中快照2，并将其上面的下拉框由默认的 Summary 选项切换为 comparison 选项，也就是对比当前快照与之前一次快照的内存区别
下图3：


我们再来看看选择 Comparison 下拉后，下方的表格列代表着什么，这里介绍几个重要的

New：新建了多少个对象
Deleted：回收了多少个对象
Delta：新建的对象数 减去 回收的对象数

诶，到这我们就有点那味儿了，我们需要重点关注 Delta ，只要它是正数就可能存在问题，贴心的控制台都已经给我们排好序了，最上面的几个我们依次看就可以。
当然，我们还需要知道这每一行的数据都代表的是什么，注意力转移到 Constructor 这一列，我们也说过，此列是构造函数，每一个构造函数点击都可以查看由该构造函数创建的所有对象，还是要先介绍下此列中常见的构造函数大致代表什么

system、system/Context 表示引擎自己创建的以及上下文创建的一些引用，这些不用太关注，不重要
closure 表示一些函数闭包中的对象引用
array、string、number、regexp 这一系列也能看出，就是引用了数组、字符串、数字或正则表达式的对象类型
HTMLDivElement、HTMLAnchorElement、DocumentFragment等等这些其实就是你的代码中对元素的引用或者指定的 DOM 对象引用

诶，又清晰了很多，那接下来我们就可以依次对比 1->2 / 2->3 / 3->4 来看到底哪里有问题了。
别着急，想一下现在的我们要怎么做？需要单独的点击一个快照再选中 comparison ，然后看 Delta 列为正数的项再进行分析，这样的操作需要进行 3 次，因为我们有 4 个快照，需要对比分析 3 次，甚至有时候可能生成的快照更多以此来确保准确性。
有没有更简单的方式呢？有的，我们可以直接选中要对比的快照，右侧表格上还有一个弹框我们可以直接选择快照进行对比，并且还会贴心的为我们过滤掉一些没用的信息：
如图4
可以看到，列表中只剩下对比过滤后的 4 项差异
system/Context 我们无需关心。
closure 上面也说过代表闭包引用，我们点击此项看一下具体的信息


可以看到， closure 下有两个引用，还贴心的为我们指出了在代码的 21 行，点击选中其中一个引用，下方还有更详细的信息展示。
为什么展开后是两个引用？还记得我们在生成 快照2 时的操作吗，手动执行了一次 GC 并点击了一次 click 按钮，触发了一次点击事件，点击事件中我们执行并 push 了两次闭包函数，所以就是 2 条记录。
最后我们看 array ，这里存在数组的引用是完全因为我们案例代码中那个全局数组变量 arr 的存在，毕竟每次点击都 push 数据呢，这也是我们上面提到的为什么要额外关注全局变量的使用、要将它及时清理什么的，就是因为像这种情况你不清理的话这些全局变量在页面关闭前就一直在内存里，可能大家对构造函数列中有 2 项都是数组有疑问，其实没毛病，一项代表的是 arr 本身，一项代表的是闭包内部引用的数组变量 test （忘了的话回顾一下上面案例代码），这点也可以通过 Distance 列中表示的引用层级来 GET，一个层级是 7，一个层级是 8。至于数组引起泄漏的代码位置我们也可以点击展开并选中其引用条目，详情里就可以看到代码位置，同上面闭包一样的操作，这里就不演示了。
如图5 6

##内存三大件
其实前端关于内存方面主要有三个问题，我把它们亲切的称作内存三大件：
内存泄漏 我们说很久了，对象已经不再使用但没有被回收，内存没有被释放，即内存泄漏，那想要避免就避免让无用数据还存在引用关系，也就是多注意我们上面说的常见的几种内存泄漏的情况。
内存膨胀 即在短时间内内存占用极速上升到达一个峰值，想要避免需要使用技术手段减少对内存的占用。
频繁 GC 同这个名字，就是 GC 执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 GC，
频繁 GC 同样会导致页面卡顿，想要避免的话就不要搞太多的临时变量，因为临时变量不用了就会被回收，这和我们内存泄漏中说避免使用全局变量冲突，其实，只要把握好其中的度，不太过分就 OK