/**
 *  作用域
 *  作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对 变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询
 *  赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域 的赋值操作
 * 
 */
/**
 * JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声 明会被分解成两个独立的步骤：
    1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 
    2. 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。

 */

/**
 * LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所 需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层 楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。
 * 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。

 */
/**
 * 在第 1 章中，我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用 域以及嵌套的子作用域中根据标识符名称进行变量查找。
   作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法 作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语 言在使用（比如 Bash 脚本、Perl 中的一些模式等）。

 */


/**
 * 简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域 不变
 */
/**
 * 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定
 */
/**
 * 块级作用域
 * let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let 为其声明的变量隐式地了所在的块作用域
 * 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过 程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将 其包含在其他的块中，就会导致代码变得混乱。

 */
if (foo) {
  { // <-- 显式的快         
    let bar = foo * 2;
    bar = something(bar);
    console.log(bar);
  }
}
console.log(bar); // ReferenceError
// 只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑 定的块。在这个例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重 构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响
// 2. let循环 一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。
for (let i = 0; i < 10; i++) {
  console.log(i);
}
console.log(i); // ReferenceError
// for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环 的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋

/**
 * 变量提升
 *
 */
foo();
function foo() {
  console.log(a); // undefined        
  var a = 2;
}

foo(); // 不是 ReferenceError, 而是 TypeError! 
var foo = function bar() {

};

//  可以看到，函数声明会被提升，但是函数表达式却不会被提升
// 函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个 “重复”声明的代码中）是函数会首先被提升，然后才是变量。
// 考虑以下代码：


foo(); // 1 

var foo;

function foo() { console.log(1); }

foo = function () { console.log(2); };
// 会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：
function foo() { console.log(1); }

foo(); // 1 

foo = function () { console.log(2); };



// --------------------------------------------------------------------------------------

foo(); // "b" 

var a = true; 
if (a) {
  function foo() { console.log("a"); }
} else {
  function foo() { console.log("b"); }
}
// 但是需要注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该 尽可能避免在块内部声明函数