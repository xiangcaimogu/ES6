// 理解js编译阶段和运行阶段
// 理解作用域和编译
// 什么叫做作用域：设计良好的规则来存储变量，并且之后可以方便地找到这些变量。 这套规则被称为作用域
// 或者是：负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限
// 编译器负责语法分析及代码生成：编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个语法树AST结构。
// 编译的作用个人理解：和作用域息息相关，编译的过程就是将语法树AST结构通知作用域形成一套作用域规则
// 下面我们将 var a = 2; 分解，看看引擎和它的朋友们是如何协同工作的。
// 编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。
// 可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内 存，将其命名为 a，然后将值 2 保存进这个变量。”然而，这并不完全正确。
// 事实上编译器会进行如下处理。
// 1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。
// 2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（查看 1.3 节）。
// 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异 常！
// 所以才会出现 在编译阶段全局变量和全局函数申明表达式提升(重点：全局变量在编译阶段不做赋值操作；运行阶段在做var = 2 的赋值操作)
// 引擎和作用域的对话 这句对话很重要
// function foo(a) {
//     console.log( a ); // 2
//  } 
// foo( 2 );
// 让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。
// 引擎：我说作用域，我需要为foo进行RHS引用。你见过它吗？
// 作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。 (在foo()运行之前，编译器进行了全局编译)
// 引擎：哥们太够意思了！好吧，我来执行一下foo。 
// 引擎：作用域，还有个事儿。我需要为a进行LHS引用，这个你见过吗？ 
// 作用域：这个也见过，编译器最近把它声名为foo的一个形式参数了，拿去吧。 (在触发函数时，编译器在函数运行前进行了函数局部编译)
// 引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给a。 //在运行时，引擎进行赋值操作 
// 引擎：哥们，不好意思又来打扰你。我要为console进行RHS引用，你见过它吗？ 
// 作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。 
// 引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。 
// 引擎：哥们，能帮我再找一下对a的RHS引用吗？虽然我记得它，但想再确认一次。
// 作用域：放心吧，这个变量没有变动过，拿走，不谢。 
// 引擎：真棒。我来把a的值，也就是2，传递进log(..)。 ……

// 总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如 果之前没有声明过），
// 然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。

// 将编译分为两次
// 一次再脚本执行前的编译(我称为全局编译) ；再有是函数运行时才会触发函数内部编译，在函数执行前一刻


// 第一个区别
// common.js 模块依赖关系的建立发生在代码运行阶段，是动态的；
// 当模块A加载模块B时（在上面的例子中是index.js加载calculator.js），
// 会执行B中的代码，并将其module.exports对象作为require函数的返回值进行返回。
// 并且require的模块路径可以动态指定，支持传入一个表达式，
// 我们甚至可以通过if语句判断是否加载某个模块。因此，在CommonJS模块被执行前，并没有办法确定明确的依赖关系，模块的导入、导出发生在代码的运行阶段
// es6模块的依赖关系是建立在代码全局编译阶段，是静态的 
// ES6 Module的导入、导出语句都是声明式的，它不支持导入的路径是一个表达式，
// 并且导入、导出语句必须位于模块的顶层作用域（比如不能放在if语句中）


// 第二个区别
// 值拷贝与动态映射

// 在导入一个模块时，对于CommonJS来说获取的是一份导出值的拷贝；而在ES6 Module中则是值的动态映射，并且这个映射是只读的
// index.js中的count是对calculator.js中count的一份值拷贝，因此在调用add函数时，虽然更改了原本calculator.js中count的值，但是并不会对index.js中导入时创建的副本造成影响。
// 另一方面，在CommonJS中允许对导入的值进行更改。我们可以在index.js更改count和add，将其赋予新值。同样，由于是值的拷贝，这些操作不会影响calculator.js本身

// 上面的例子展示了ES6 Module中导入的变量其实是对原有值的动态映射。index.js中的count是对calculator.js中的count值的实时反映，当我们通过调用add函数更改了calculator.js中count值时，index.js中count的值也随之变化。
// 我们不可以对ES6 Module导入的变量进行更改，可以将这种映射关系理解为一面镜子，从镜子里我们可以实时观察到原有的事物，但是并不可以操纵镜子中的影像

