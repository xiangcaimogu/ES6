<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
    <script src="jquery.js" charset="utf-8"></script>
    <script>
        function runAsync() {

            let p = new Promise(function (resolve, reject) {//作为参数传入两个方法
                //异步代码
                //resolve——成功了,
                //promise对象里面包含了很多方法，Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。
                // 其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。
                //在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。
                //运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，
                // 在需要的时候去运行这个函数在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。
                // 这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，
                // 简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。
                // 你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样:
                // function runAsync(callback){
                //     setTimeout(function(){
                //         console.log('执行完成');
                //         callback('随便什么数据');
                //     }, 2000);
                // }
                //
                // runAsync(function(data){
                //     console.log(data);
                // });
                // 效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2
                // 然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作
                $.ajax({
                    url: 'data/arr2.txt',
                    dataType: 'json',
                    success(arr) {
                        resolve(arr);//这里的arr会通过resolve方法传给then方法
                    },
                    error(err) {
                        reject(err);
                    }
                })
            });
            return p
        }
        runAsync()
        runAsync().then(function (arr) {
            alert('成功' + arr);
        }, function (err) {
            console.log(err);
            alert('失败了' + err);
        });
    </script>
</head>
<body>

</body>
</html>
