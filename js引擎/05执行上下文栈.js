// 1.在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象
// 2.在全局执行上下文确定后，将其添加到栈中（压栈）(先进后出)
// 3.在函数执行上下文创建后(函数执行才会创建上下文)，将其添加到栈中（压栈）
// 4.在当前函数执行后，将栈顶的对象移除
// 5.当所有代码执行完成后，栈中只剩下window
// execution context stack


//1.进入全局执行创建上下文对象
var a = 10;
var bar = function (x) {
    var b = 3;
    foo(x + b)//3.进入foo函数执行创建上下文对象
}
var foo = function (y) {
    var c = 8
    console.log(a + c + y)
}
var fon=function(){
    var b=9
    //....
}
bar()//2.进入bar函数执行创建上下文对象
fon()
//函数执行才会创建函数上下文//这边是2个加上window一共三个上下文栈
//1.进入全局执行创建上下文对象 压栈
//2.执行bar函数创建上下文对象  压栈
//3.遇到foo函数，执行foo，创建上下文对象  压栈
//4.foo函数上下文在栈顶，执行完foo，释放foo上下文
//5.foo出栈，然后bar在栈顶，继续释放bar，剩下window
// bar 出栈之后才会执行后面的同级函数fon() ,然后fon才会进栈(压栈)
//重点：同级函数上下文，需要等上一个函数执行出栈，同级函数才会进栈
//重点总结: 这就是为什么内部函数可以引用外部作用域变量，且内部函数不释放，外部函数就不会释放，
//重点: 这就引出闭包的原因:内部函数在当前函数作用域的外部被引用,外部一直引用导致内部函数不能释放，导致当前函数作用域不能释放
//重点: 但是闭包多了会占用栈内存
function bar(){
    let a=1
    var foo=function(){
        return a++
    }
    return foo
}
let fn=bar()
//...直到fn=null,释放函数foo

//局部变量：在函数内部声明的变量叫做局部变量，生命周期  函数调用时生成，函数调用完毕后销毁(GC回收)
//全局变量：在函数外部声明的变量叫做全局变量，声明周期  页面打开时生成，关闭后销毁
//回收机制
//2种
//标记清除法  谷歌
//引用计数法  IE