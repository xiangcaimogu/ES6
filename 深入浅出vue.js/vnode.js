// 5.1什么是虚拟DOM
// 重点：虚拟 DOM 的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。 
// 在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的 部分。

// Vue.js 2.0 开始选择了一个中等粒度的解决方案，那就是引入了虚拟 DOMo 组件级别 是一个 watcher 实例，就是说即便一个组件内有 10 个节点使用了某个状态，
// 但其实也只有一个 watcher 在观察 这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部 通过虚拟 DOM 去进行 比对与渲染。这是一个比较折中的方案
// 在 Vue.js 中，我们使用模板来描述状态与 DOM 之间的映射关系。Vue.js 通过编译将模板转 换成渲 染函数(render),执行渲染函数就可以得到一个虚拟节点树，使用这个虚拟节点树就可以 渲染页面
//例如，一个 ul 标签下有很多 H 标签，其中只有一个 li 有变化，这种情况下如果使用新的 ul 去替换 旧的 ul,其实除了那个发生了变化的 M 节点之外，其他节点都不需要重新渲染。 
//由于 DOM 操作比较慢，所以这些 DOM 操作在性能上会有一定的浪费，避免这些不必要的 DOM 操作会提升很大一部分性能。 
//为了避免不必要的 DOM 操作，虚拟 DOM 在虚拟节点映射到视图的过程中，将虚拟节点与 上一次 渲染视图所使用的旧虚拟节点（oldVnode ）做对比，找出真正需要更新的节点来进行 DOM 操作，
//从而 避免操作其他无任何改动的 DOM
// 重点：根据上面的中等粒度解决方案,Watch观察组件状态，状态发生改变，会使用当前的状态和模板生成新的虚拟节点树，虚拟 DOM 在虚拟节点映射到视图的过程中，将虚拟节点与 上一次 渲染视图所使用的旧虚拟节点（oldVnode ）做对比，找出真正需要更新的节点来进行 DOM 操作


// 6 vnode 虚拟节点



// 7.5.1 更新策略
// patch 对两个虚拟节点进行比对是虚拟 DOM 中最核心的算法（即 patch）,它可以判断出哪些节 点发生了 变化，从而只对发生了变化的节点进行更新操作。
// 之所以要这么做，主要是因为 DOM 操作的执行速度远不如 JavaScript 的运算速度快。因此， 把大 量的 DOM 操作搬运到 JavaScript 中，使用 patching 算法来计算出真正需要更新的节点，最 大限度地减 少 DOM 操作，
//从而显著提升性能。这本质上其实是使用 JavaScript 的运算成本来替 换 DOM 操作的执 行成本，而 JavaScript 的运算速度要比 DOM 快很多，这样做很划算，所以才 会有虚拟 DOM

// 1 .创建子节点
// 当在右下角的 虚拟子 节点中找不到与左下角的第三个节点相同的节点时，证明它是新增节点，这时候需要创建 
// 节点并插入 到真实 DOM 中，插入的位置是所有未处理节点的前面。 
// 你可能会说，插入到所有已处理节点的后面不也行吗？
// 答：不行，新增的节点虽然也是已处理的节点，但是我们是循环旧节点与新节点对比，所以实际已处理节点不算新增节点的，所以如果后面还是新增节点，
// 如果插在已处理的后面，它会插在已处理的旧节点后面，也就是上一个新节点的前面，而我们需要它插在前一个新节点的后面，
// 所以我们新节点都是插在未处理的节点前面，而不是已处理节点的后面，关键就是已处理的节点是不算新增节点的
// 4. 删除子节点
// 可以得出结论，当 newChildren 中的所有节点都被循环了一遍后，也就是循环结束后，
// 如 果 oldChildren 中还有剩余的没有被处理的节点，那么这些节点就是被废弃、需要删除的节点。


//8 模板编译

// 平时使用模板时，可以在模板中使用一些变量来填充模板，还可以在模板中使用 JavaScript 表达式， 又或者是使用一些指令等。 这些功能在 HTML 语法中是不存在的，那么为什么在 Vue.js 的模板中就可以使用各种很灵 活的语 法呢？这就多亏了模板编译赋予了模板强大的功能。 
//模板编译的主要目标就是生成渲染函数，如图 8.2 所示。而渲染函数的作用是每次执行它， 它就 会使用当前最新的状态生成一份新的 vnode,然后使用这个 vnode 进行渲染。
// 将模板编译成渲染函数可以分两个步骤，先将模板解析成 AST（Abstract Syntax Tree,抽象 语法树）， 然后再使用 AST 生成渲染函数。 
// 但是由于静态节点不需要总是重新渲染，所以在生成 AST 之后、生成渲染函数之前这个阶 段，需 要做一个操作，那就是遍历一遍 AST,给所有静态节点做一个标记，
// 这样在虚拟 DOM 中 更新节点时， 如果发现节点有这个标记，就不会重新渲染它。 所以，在大体逻辑上，
// 模板编译分三部分内容： □将模板解析为 AST 口遍历 AST 标记静态节点 □使用 AST 生成渲染函数 
// 这三部分内容在模板编译中分别抽象岀三个模块来实现各自的功能，分别是: 口解析器 口优化器 □代码生成器 图 8-3 给岀了模板编译的整体流程